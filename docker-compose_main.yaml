services:
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #-------------------------------------------------------------------------------------------------------------#
  gateway:
    image: fr-server-gateway_server_service:latest
    container_name: fr_gateway
    environment:
      - NAMESPACE=${SERVER_NAME}
      - SERVICE_TYPE=gateway
      - TZ=Africa/Cairo
      - CONFIG_PROFILE=${CONFIG_PROFILE:-prod-1gpu-24gb}
      - SERVER_IP=0.0.0.0
      - SERVER_PORT=8001
      - ENDPOINT_PATH=/ws
      - REDIS_HOSTNAME=Redis_Server
      - REDIS_HOSTPORT=6379
      - RMQ_URL=amqp://admin:admin123@rmq_Server:5672
      - DISABLE_APP_RATE_LIMITER=true
      - STORAGE_ENDPOINT=${STORAGE_ENDPOINT:-minio:9000}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - STORAGE_SECURE=${STORAGE_SECURE:-false}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
    volumes:
      - type: bind
        source: ${DATA_DIR}/logs/${SERVER_NAME}
        target: /app/${SERVER_NAME}/logs
      - type: bind
        source: ${DATA_DIR}
        target: /app/Data
    depends_on:
      minio:
        condition: service_healthy
      Redis_Server:
        condition: service_started
      rmq_Server:
        condition: service_started
      Load_Balancer:
        condition: service_started
    ports:
      - "0.0.0.0:${GATEWAY_PORT:-8001}:8001"
    networks:
      - load_balance_network
      - redis_network
      - rmq_network
      - storage_network
    restart: unless-stopped
  face-ingestor:
    build:
      context: ./services/Face_Ingest_Service
      dockerfile: Dockerfile
    image: fr-face-ingestor:latest
    # Align container UID/GID with GUI (node user is 1000:1000) so volume writes stay writable.
    user: "${PUID:-1000}:${PGID:-1000}"
    container_name: fr_face_ingestor
    environment:
      - TZ=Africa/Cairo
      - INGESTOR_PORT=${INGESTOR_PORT:-8010}
      # Pipeline queue lives in-process; keep workers at 1 so ingest/execute share the same queue.
      - INGESTOR_WORKERS=${INGESTOR_WORKERS:-1}
      - PHONE_DETECTION_WEIGHTS=${PHONE_DETECTION_WEIGHTS:-/app/Models_Weights/phone_detection/phone_detection.pt}
      - PHONE_DETECTION_CLASS=${PHONE_DETECTION_CLASS:-67}
      - PHONE_DETECTION_THRESHOLD=${PHONE_DETECTION_THRESHOLD:-0.35}
      - PHONE_DETECTION_DEVICE=${PHONE_DETECTION_DEVICE:-cpu}
    expose:
      - "${INGESTOR_PORT:-8010}"
    networks:
      - storage_network
      - gui_network
    volumes:
      - type: bind
        source: ${ROOT_PATH}/Models_Weights
        target: /app/Models_Weights
      - type: bind
        source: ${DATA_DIR}
        target: /app/Data
    restart: unless-stopped
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #-------------------------------------------------------------------------------------------------------------#
  # Pipeline Manager Service
  pipelines-manager:
    image: fr-server-pipelines_manager_service:latest
    container_name: fr_pipelines_manager
    environment:
      - NAMESPACE=${SERVER_NAME}
      - SERVICE_TYPE=pipelines-manager
      - TZ=Africa/Cairo
      - CONFIG_PROFILE=${CONFIG_PROFILE:-prod-1gpu-24gb}
      - REDIS_HOSTNAME=Redis_Server
      - REDIS_HOSTPORT=6379
      - RMQ_URL=amqp://admin:admin123@rmq_Server:5672
    volumes:
      - type: bind
        source: ${DATA_DIR}/logs/${SERVER_NAME}
        target: /app/${SERVER_NAME}/logs
    depends_on:
      - Redis_Server
      - rmq_Server
    networks:
      - redis_network
      - rmq_network
      - storage_network
    restart: unless-stopped
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #-------------------------------------------------------------------------------------------------------------#
  # Decision Manager Service
  decision-manager:
    image: fr-server-decision_manager_service:latest
    container_name: fr_decision_manager
    environment:
      - SERVICE_TYPE=decision-manager
      - TZ=Africa/Cairo
      - RMQ_URL=amqp://admin:admin123@rmq_Server:5672
      - NAMESPACE=${SERVER_NAME}
    volumes:
      - type: bind
        source: ${DATA_DIR}/logs/${SERVER_NAME}
        target: /app/${SERVER_NAME}/logs
      - type: bind
        source: ${DATA_DIR}
        target: /app/Data
    depends_on:
      - rmq_Server
    networks:
      - rmq_network
      - storage_network
    restart: unless-stopped
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #-------------------------------------------------------------------------------------------------------------#
  # Server Manager Service
  server-manager:
    image: fr-server-server_manager_service:latest
    container_name: fr_server_manager
    ports:
      - "0.0.0.0:${SERVER_MANAGER_PORT}:${SERVER_MANAGER_PORT}"
    environment:
      - SERVICE_TYPE=server-manager
      - NAMESPACE=${SERVER_NAME}
      - SERVER_NAME=${SERVER_NAME}
      - TZ=Africa/Cairo
      - REDIS_HOSTNAME=Redis_Server
      - REDIS_HOSTPORT=6379
      - RMQ_URL=amqp://admin:admin123@rmq_Server:5672
      - GUI_BACKEND_IP=${SERVER_MANAGER_1_IP}
      - GUI_BACKEND_PORT=${SERVER_MANAGER_PORT}
      - GUI_ORIGIN_URL=${GUI_ORIGIN_IP}:${GUI_ORIGIN_PORT}
    volumes:
      - type: bind
        source: ${DATA_DIR}/logs/${SERVER_NAME}
        target: /app/${SERVER_NAME}/logs
      - type: bind
        source: ${DATA_DIR}
        target: /app/Data
    depends_on:
      - rmq_Server
      - Redis_Server
    networks:
      redis_network:
      rmq_network:
      storage_network:
      gui_network:
    restart: unless-stopped
  #-------------------------------------------------------------------------------------------------------------#
  #MinIO Server
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  minio:
    image: minio/minio:latest
    container_name: fr_minio
    command: server /data --console-address ":9001"
    environment:
      - TZ=Africa/Cairo
      - MINIO_REGION_NAME=${STORAGE_REGION:-us-east-1}
      - MINIO_ROOT_USER=${STORAGE_ACCESS_KEY:-minioadmin}
      - MINIO_ROOT_PASSWORD=${STORAGE_SECRET_KEY:-minioadmin}
    ports:
      - "${MINIO_API_PORT:-9100}:9000" # S3 API
      - "${MINIO_CONSOLE_PORT:-9001}:9001" # Console
    volumes:
      - /srv/minio:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/ready"]
      interval: 30s
      timeout: 20s
      retries: 3
      start_period: 60s
    networks:
      storage_network:
        aliases:
          - minio
      gui_network:
        aliases:
          - minio
  logrotate:
    image: blacklabelops/logrotate:latest
    container_name: fr_logrotate
    environment:
      - TZ=Africa/Cairo
      - SERVER_NAME=${SERVER_NAME}
      - LOGS_DIRECTORIES=/logs/${SERVER_NAME}
      - LOGROTATE_INTERVAL=hourly
      - LOGROTATE_COPIES=1
      - LOGROTATE_SIZE=5M
      - LOGROTATE_COMPRESSION=compress
      - LOGROTATE_CRONSCHEDULE=*/20 * * * *
      - LOGROTATE_LOGFILE=/logs/logrotate.log
      - LOGROTATE_STATUSFILE=/logs/logrotate.status
      - LOG_FILE=/logs/logrotate.log
      - LOG_FILE_DATE_FORMAT=-%Y%m%d-%H%M%S
    volumes:
      - type: bind
        source: ${DATA_DIR}/logs
        target: /logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "test -f /logs/logrotate.log"]
      interval: 5m
      timeout: 10s
      retries: 3
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  # MinIO Cleanup Service 
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  # Six concurrent workers split the minute ranges into 10-minute shards.
  # Each worker caps deletions per cycle to avoid overloading MinIO.
  minio-cleanup-00-09:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_00_09
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=0
      - MIN_END=9
      - STARTUP_DELAY=8
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 00-09] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 00-09] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped

  minio-cleanup-10-19:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_10_19
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=10
      - MIN_END=19
      - STARTUP_DELAY=10
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 10-19] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 10-19] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped

  minio-cleanup-20-29:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_20_29
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=20
      - MIN_END=29
      - STARTUP_DELAY=12
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 20-29] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 20-29] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped

  minio-cleanup-30-39:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_30_39
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=30
      - MIN_END=39
      - STARTUP_DELAY=14
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 30-39] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 30-39] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped

  minio-cleanup-40-49:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_40_49
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=40
      - MIN_END=49
      - STARTUP_DELAY=16
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 40-49] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 40-49] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped

  minio-cleanup-50-59:
    image: minio/mc:latest
    container_name: fr_minio_cleanup_50_59
    environment:
      - TZ=${TZ:-Africa/Cairo}
      - STORAGE_FRAMES_BUCKET=${STORAGE_FRAMES_BUCKET:-face-frames}
      - RETENTION_HOURS=${RETENTION_HOURS:-0.33}
      - STORAGE_ACCESS_KEY=${STORAGE_ACCESS_KEY:-minioadmin}
      - STORAGE_SECRET_KEY=${STORAGE_SECRET_KEY:-minioadmin}
      - CLEANUP_INTERVAL_MINUTES=5
      - CLEANUP_MAX_OBJECTS=${CLEANUP_MAX_OBJECTS:-500}
      - MIN_START=50
      - MIN_END=59
      - STARTUP_DELAY=18
    entrypoint: >
      sh -c "
        export TZ=$${TZ:-UTC};
        DATE_CMD='env TZ='$${TZ:-UTC}' date';
        echo \"[$($DATE_CMD)] [Cleanup 50-59] Starting cleanup...\";
        sleep $${STARTUP_DELAY};
        mc alias set myminio http://minio:9000 $${STORAGE_ACCESS_KEY} $${STORAGE_SECRET_KEY};
        mc mb myminio/$${STORAGE_FRAMES_BUCKET} || true;
        mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1 || printf '' | mc pipe myminio/$${STORAGE_FRAMES_BUCKET}/frames/.keep >/dev/null 2>&1 || true;
        while true; do
          echo \"[$($DATE_CMD)] [Cleanup 50-59] Running cleanup\";
          if mc ls myminio/$${STORAGE_FRAMES_BUCKET}/frames >/dev/null 2>&1; then
            mc find myminio/$${STORAGE_FRAMES_BUCKET}/frames/ --older-than $${RETENTION_HOURS}h | head -n $${CLEANUP_MAX_OBJECTS} | while read -r object; do
              [ -n \"$${object}\" ] && mc rm --force \"$${object}\" 2>/dev/null || true;
            done;
          fi
          sleep $$(( $${CLEANUP_INTERVAL_MINUTES} * 60 ));
        done
      "
    networks:
      - storage_network
    restart: unless-stopped
  #-------------------------------------------------------------------------------------------------------------#
  #Redis Server
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  Redis_Server:
    image: redis:8.0.2
    container_name: Redis_Server
    hostname: Redis_Server
    restart: unless-stopped
    environment:
      - TZ=Africa/Cairo
    command: redis-server --save "" --appendonly no
    volumes:
      - type: volume
        source: redis_data
        target: /data
    networks:
      redis_network:
        aliases:
          - Redis_Server
  #-------------------------------------------------------------------------------------------------------------#
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #RabbitMQ Server
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  rmq_Server:
    image: rabbitmq:4-management
    container_name: rmq_Server
    restart: unless-stopped
    environment:
      TZ: Africa/Cairo
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin123
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - type: volume
        source: rmq_data
        target: /var/lib/rabbitmq
    networks:
      - rmq_network
      - rmq_network_gui
  #-------------------------------------------------------------------------------------------------------------#
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  #Load Balancer
  #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#
  Load_Balancer:
    image: fr_loadbalance:0
    restart: unless-stopped
    environment:
      - GATEWAY_HOST=fr_gateway
      - GATEWAY_PORT=8001
      - TZ=Africa/Cairo
      - NGINX_PORT=80
      - NGINX_WORKER_PROCESSES=auto
      - NGINX_WORKER_OPEN_FILES=65535
      - NGINX_WORKER_CONNECTIONS=16384
      - NGINX_RATE_LIMIT_ZONE=1m
      - TOTAL_CLIENTS=200
      - NGINX_RATE_LIMIT_RPS=6
      - NGINX_RATE_LIMIT_CONN=6
      - NGINX_RATE_LIMIT_BURST=10
      - NGINX_RATE_LIMIT_ZONE_GLOBAL=1m
      - NGINX_RATE_LIMIT_RPS_GLOBAL=200
      - NGINX_RATE_LIMIT_CONN_GLOBAL=200
      - NGINX_RATE_LIMIT_BURST_GLOBAL=20
    networks:
      - fr_network
      - load_balance_network
    ports:
      - "8000:80"
    volumes:
      - ${ROOT_PATH}/config_templates/nginx.conf.template:/etc/nginx/templates/nginx.conf.template:ro
    command: >
      /bin/sh -c '
        # Ensure sane defaults to avoid empty directives in nginx.conf
        WP=$${NGINX_WORKER_PROCESSES:-auto};
        case "$$WP" in ""|*[!0-9a-zA-Z]*) WP=auto ;; esac
        export NGINX_WORKER_PROCESSES=$$WP;
        export NGINX_WORKER_OPEN_FILES=$${NGINX_WORKER_OPEN_FILES:-65535};
        export NGINX_WORKER_CONNECTIONS=$${NGINX_WORKER_CONNECTIONS:-4096};
        export NGINX_RATE_LIMIT_ZONE=$${NGINX_RATE_LIMIT_ZONE:-20m};
        export NGINX_RATE_LIMIT_BURST=$${NGINX_RATE_LIMIT_BURST:-20};
        RATE=$${NGINX_RATE_LIMIT_RPS:-$$((TOTAL_CLIENTS*2))};
        CONN=$${NGINX_RATE_LIMIT_CONN:-$$((TOTAL_CLIENTS*2))};
        export NGINX_RATE_LIMIT_RPS=$$RATE;
        export NGINX_RATE_LIMIT_CONN=$$CONN;

        # Global caps across all clients (defaults scale off TOTAL_CLIENTS if not provided)
        export NGINX_RATE_LIMIT_ZONE_GLOBAL=$${NGINX_RATE_LIMIT_ZONE_GLOBAL:-$${NGINX_RATE_LIMIT_ZONE:-20m}};
        GRATE=$${NGINX_RATE_LIMIT_RPS_GLOBAL:-$$((TOTAL_CLIENTS*5))};
        GCONN=$${NGINX_RATE_LIMIT_CONN_GLOBAL:-$$((TOTAL_CLIENTS*20))};
        GBURST=$${NGINX_RATE_LIMIT_BURST_GLOBAL:-$$((NGINX_RATE_LIMIT_BURST*2))};
        export NGINX_RATE_LIMIT_RPS_GLOBAL=$$GRATE;
        export NGINX_RATE_LIMIT_CONN_GLOBAL=$$GCONN;
        export NGINX_RATE_LIMIT_BURST_GLOBAL=$$GBURST;
        export NGINX_DOLLAR="$$";  # keep nginx runtime dollar vars intact during envsubst
        # Render nginx.conf with all exported env vars
        envsubst < /etc/nginx/templates/nginx.conf.template > /etc/nginx/nginx.conf;
        nginx -g "daemon off;"
      '

#**************************************************************************************************************#
#**************************************************************************************************************#
volumes:
  redis_data:
    driver: local
  #______________________________________________________________________________________________________________#
  rmq_data:
    driver: local
  #______________________________________________________________________________________________________________#
  minio_data:
    driver: local
#**************************************************************************************************************#
networks:
  load_balance_network:
    external: true
    name: load_balance_network
  #______________________________________________________________________________________________________________#
  rmq_network:
    external: true
    name: rmq_network
  #______________________________________________________________________________________________________________#
  rmq_network_gui:
    external: true
    name: rmq_network_gui
  #______________________________________________________________________________________________________________#
  gui_network:
    external: true
    name: fr_gui_network
  #______________________________________________________________________________________________________________#
  redis_network:
    external: true
    name: redis_network
  #______________________________________________________________________________________________________________#
  fr_network:
    external: true
    name: fr_network
  #______________________________________________________________________________________________________________#
  storage_network:
    external: true
    name: storage_network
